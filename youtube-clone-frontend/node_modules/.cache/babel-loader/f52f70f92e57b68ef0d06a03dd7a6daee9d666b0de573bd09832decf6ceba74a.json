{"ast":null,"code":"/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['moment'], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but only CommonJS-like\n    // enviroments that support module.exports, like Node.\n    try {\n      module.exports = factory(require('moment'));\n    } catch (e) {\n      // If moment is not available, leave the setup up to the user.\n      // Like when using moment-timezone or similar moment-based package.\n      module.exports = factory;\n    }\n  }\n  if (root) {\n    // Globals.\n    root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n  }\n})(this, function (moment) {\n  // `Number#tolocaleString` is tested on plugin initialization.\n  // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n  // native function will be used to generate formatted output. If the feature\n  // test fails, the fallback format function internal to this plugin will be\n  // used.\n  var toLocaleStringWorks = false;\n\n  // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `toLocaleString` will be used for formatting,\n  // the plugin will \"pre-round\" number values using the fallback number format\n  // function before passing them to `toLocaleString` for final formatting.\n  var toLocaleStringRoundingWorks = false;\n\n  // `Intl.NumberFormat#format` is tested on plugin initialization.\n  // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n  // `true` and the native function will be used to generate formatted output.\n  // If the feature test fails, either `Number#tolocaleString` (if\n  // `toLocaleStringWorks` is `true`), or the fallback format function internal\n  //  to this plugin will be used.\n  var intlNumberFormatWorks = false;\n\n  // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n  // formatting, the plugin will \"pre-round\" number values using the fallback number\n  // format function before passing them to `Intl.NumberFormat#format` for final\n  // formatting.\n  var intlNumberFormatRoundingWorks = false;\n\n  // Token type names in order of descending magnitude.\n  var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n  var bubbles = [{\n    type: \"seconds\",\n    targets: [{\n      type: \"minutes\",\n      value: 60\n    }, {\n      type: \"hours\",\n      value: 3600\n    }, {\n      type: \"days\",\n      value: 86400\n    }, {\n      type: \"weeks\",\n      value: 604800\n    }, {\n      type: \"months\",\n      value: 2678400\n    }, {\n      type: \"years\",\n      value: 31536000\n    }]\n  }, {\n    type: \"minutes\",\n    targets: [{\n      type: \"hours\",\n      value: 60\n    }, {\n      type: \"days\",\n      value: 1440\n    }, {\n      type: \"weeks\",\n      value: 10080\n    }, {\n      type: \"months\",\n      value: 44640\n    }, {\n      type: \"years\",\n      value: 525600\n    }]\n  }, {\n    type: \"hours\",\n    targets: [{\n      type: \"days\",\n      value: 24\n    }, {\n      type: \"weeks\",\n      value: 168\n    }, {\n      type: \"months\",\n      value: 744\n    }, {\n      type: \"years\",\n      value: 8760\n    }]\n  }, {\n    type: \"days\",\n    targets: [{\n      type: \"weeks\",\n      value: 7\n    }, {\n      type: \"months\",\n      value: 31\n    }, {\n      type: \"years\",\n      value: 365\n    }]\n  }, {\n    type: \"months\",\n    targets: [{\n      type: \"years\",\n      value: 12\n    }]\n  }];\n\n  // stringIncludes\n  function stringIncludes(str, search) {\n    if (search.length > str.length) {\n      return false;\n    }\n    return str.indexOf(search) !== -1;\n  }\n\n  // repeatZero(qty)\n  // Returns \"0\" repeated `qty` times.\n  // `qty` must be a integer >= 0.\n  function repeatZero(qty) {\n    var result = \"\";\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n    return result;\n  }\n  function stringRound(digits) {\n    var digitsArray = digits.split(\"\").reverse();\n    var i = 0;\n    var carry = true;\n    while (carry && i < digitsArray.length) {\n      if (i) {\n        if (digitsArray[i] === \"9\") {\n          digitsArray[i] = \"0\";\n        } else {\n          digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n          carry = false;\n        }\n      } else {\n        if (parseInt(digitsArray[i], 10) < 5) {\n          carry = false;\n        }\n        digitsArray[i] = \"0\";\n      }\n      i += 1;\n    }\n    if (carry) {\n      digitsArray.push(\"1\");\n    }\n    return digitsArray.reverse().join(\"\");\n  }\n\n  // cachedNumberFormat\n  // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n  // On first use of a particular configuration, the instance is cached for fast\n  // repeat access.\n  function cachedNumberFormat(locale, options) {\n    // Create a sorted, stringified version of `options`\n    // for use as part of the cache key\n    var optionsString = map(keys(options).sort(), function (key) {\n      return key + ':' + options[key];\n    }).join(',');\n\n    // Set our cache key\n    var cacheKey = locale + '+' + optionsString;\n\n    // If we don't have this configuration cached, configure and cache it\n    if (!cachedNumberFormat.cache[cacheKey]) {\n      cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n    }\n\n    // Return the cached version of this configuration\n    return cachedNumberFormat.cache[cacheKey];\n  }\n  cachedNumberFormat.cache = {};\n\n  // formatNumber\n  // Formats any number greater than or equal to zero using these options:\n  // - userLocale\n  // - useToLocaleString\n  // - useGrouping\n  // - grouping\n  // - maximumSignificantDigits\n  // - minimumIntegerDigits\n  // - fractionDigits\n  // - groupingSeparator\n  // - decimalSeparator\n  //\n  // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n  // `userLocale` option is passed through to the formatting function.\n  // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n  // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n  function formatNumber(number, options, userLocale) {\n    var useToLocaleString = options.useToLocaleString;\n    var useGrouping = options.useGrouping;\n    var grouping = useGrouping && options.grouping.slice();\n    var maximumSignificantDigits = options.maximumSignificantDigits;\n    var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n    var fractionDigits = options.fractionDigits || 0;\n    var groupingSeparator = options.groupingSeparator;\n    var decimalSeparator = options.decimalSeparator;\n    if (useToLocaleString && userLocale) {\n      var localeStringOptions = {\n        minimumIntegerDigits: minimumIntegerDigits,\n        useGrouping: useGrouping\n      };\n      if (fractionDigits) {\n        localeStringOptions.maximumFractionDigits = fractionDigits;\n        localeStringOptions.minimumFractionDigits = fractionDigits;\n      }\n\n      // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n      // when maximumSignificantDigits is set. See #96.\n      if (maximumSignificantDigits && number > 0) {\n        localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n      }\n      if (intlNumberFormatWorks) {\n        if (!intlNumberFormatRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n        return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n      } else {\n        if (!toLocaleStringRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n        return number.toLocaleString(userLocale, localeStringOptions);\n      }\n    }\n    var numberString;\n\n    // Add 1 to digit output length for floating point errors workaround. See below.\n    if (maximumSignificantDigits) {\n      numberString = number.toPrecision(maximumSignificantDigits + 1);\n    } else {\n      numberString = number.toFixed(fractionDigits + 1);\n    }\n    var integerString;\n    var fractionString;\n    var exponentString;\n    var temp = numberString.split(\"e\");\n    exponentString = temp[1] || \"\";\n    temp = temp[0].split(\".\");\n    fractionString = temp[1] || \"\";\n    integerString = temp[0] || \"\";\n\n    // Workaround for floating point errors in `toFixed` and `toPrecision`.\n    // (3.55).toFixed(1); --> \"3.5\"\n    // (123.55 - 120).toPrecision(2); --> \"3.5\"\n    // (123.55 - 120); --> 3.549999999999997\n    // (123.55 - 120).toFixed(2); --> \"3.55\"\n    // Round by examing the string output of the next digit.\n\n    // *************** Implement String Rounding here ***********************\n    // Check integerString + fractionString length of toPrecision before rounding.\n    // Check length of fractionString from toFixed output before rounding.\n    var integerLength = integerString.length;\n    var fractionLength = fractionString.length;\n    var digitCount = integerLength + fractionLength;\n    var digits = integerString + fractionString;\n    if (maximumSignificantDigits && digitCount === maximumSignificantDigits + 1 || !maximumSignificantDigits && fractionLength === fractionDigits + 1) {\n      // Round digits.\n      digits = stringRound(digits);\n      if (digits.length === digitCount + 1) {\n        integerLength = integerLength + 1;\n      }\n\n      // Discard final fractionDigit.\n      if (fractionLength) {\n        digits = digits.slice(0, -1);\n      }\n\n      // Separate integer and fraction.\n      integerString = digits.slice(0, integerLength);\n      fractionString = digits.slice(integerLength);\n    }\n\n    // Trim trailing zeroes from fractionString because toPrecision outputs\n    // precision, not significant digits.\n    if (maximumSignificantDigits) {\n      fractionString = fractionString.replace(/0*$/, \"\");\n    }\n\n    // Handle exponent.\n    var exponent = parseInt(exponentString, 10);\n    if (exponent > 0) {\n      if (fractionString.length <= exponent) {\n        fractionString = fractionString + repeatZero(exponent - fractionString.length);\n        integerString = integerString + fractionString;\n        fractionString = \"\";\n      } else {\n        integerString = integerString + fractionString.slice(0, exponent);\n        fractionString = fractionString.slice(exponent);\n      }\n    } else if (exponent < 0) {\n      fractionString = repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString;\n      integerString = \"0\";\n    }\n    if (!maximumSignificantDigits) {\n      // Trim or pad fraction when not using maximumSignificantDigits.\n      fractionString = fractionString.slice(0, fractionDigits);\n      if (fractionString.length < fractionDigits) {\n        fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n      }\n\n      // Pad integer when using minimumIntegerDigits\n      // and not using maximumSignificantDigits.\n      if (integerString.length < minimumIntegerDigits) {\n        integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n      }\n    }\n    var formattedString = \"\";\n\n    // Handle grouping.\n    if (useGrouping) {\n      temp = integerString;\n      var group;\n      while (temp.length) {\n        if (grouping.length) {\n          group = grouping.shift();\n        }\n        if (formattedString) {\n          formattedString = groupingSeparator + formattedString;\n        }\n        formattedString = temp.slice(-group) + formattedString;\n        temp = temp.slice(0, -group);\n      }\n    } else {\n      formattedString = integerString;\n    }\n\n    // Add decimalSeparator and fraction.\n    if (fractionString) {\n      formattedString = formattedString + decimalSeparator + fractionString;\n    }\n    return formattedString;\n  }\n\n  // durationLabelCompare\n  function durationLabelCompare(a, b) {\n    if (a.label.length > b.label.length) {\n      return -1;\n    }\n    if (a.label.length < b.label.length) {\n      return 1;\n    }\n\n    // a must be equal to b\n    return 0;\n  }\n\n  // durationGetLabels\n  function durationGetLabels(token, localeData) {\n    var labels = [];\n    each(keys(localeData), function (localeDataKey) {\n      if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n        return;\n      }\n      var labelType = localeDataKey.slice(15).toLowerCase();\n      each(keys(localeData[localeDataKey]), function (labelKey) {\n        if (labelKey.slice(0, 1) === token) {\n          labels.push({\n            type: labelType,\n            key: labelKey,\n            label: localeData[localeDataKey][labelKey]\n          });\n        }\n      });\n    });\n    return labels;\n  }\n\n  // durationPluralKey\n  function durationPluralKey(token, integerValue, decimalValue) {\n    // Singular for a value of `1`, but not for `1.0`.\n    if (integerValue === 1 && decimalValue === null) {\n      return token;\n    }\n    return token + token;\n  }\n  var engLocale = {\n    durationLabelsStandard: {\n      S: 'millisecond',\n      SS: 'milliseconds',\n      s: 'second',\n      ss: 'seconds',\n      m: 'minute',\n      mm: 'minutes',\n      h: 'hour',\n      hh: 'hours',\n      d: 'day',\n      dd: 'days',\n      w: 'week',\n      ww: 'weeks',\n      M: 'month',\n      MM: 'months',\n      y: 'year',\n      yy: 'years'\n    },\n    durationLabelsShort: {\n      S: 'msec',\n      SS: 'msecs',\n      s: 'sec',\n      ss: 'secs',\n      m: 'min',\n      mm: 'mins',\n      h: 'hr',\n      hh: 'hrs',\n      d: 'dy',\n      dd: 'dys',\n      w: 'wk',\n      ww: 'wks',\n      M: 'mo',\n      MM: 'mos',\n      y: 'yr',\n      yy: 'yrs'\n    },\n    durationTimeTemplates: {\n      HMS: 'h:mm:ss',\n      HM: 'h:mm',\n      MS: 'm:ss'\n    },\n    durationLabelTypes: [{\n      type: \"standard\",\n      string: \"__\"\n    }, {\n      type: \"short\",\n      string: \"_\"\n    }],\n    durationPluralKey: durationPluralKey\n  };\n\n  // isArray\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  }\n\n  // isObject\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  }\n\n  // findLast\n  function findLast(array, callback) {\n    var index = array.length;\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  }\n\n  // find\n  function find(array, callback) {\n    var index = 0;\n    var max = array && array.length || 0;\n    var match;\n    if (typeof callback !== \"function\") {\n      match = callback;\n      callback = function (item) {\n        return item === match;\n      };\n    }\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n      index += 1;\n    }\n  }\n\n  // each\n  function each(array, callback) {\n    var index = 0,\n      max = array.length;\n    if (!array || !max) {\n      return;\n    }\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n      index += 1;\n    }\n  }\n\n  // map\n  function map(array, callback) {\n    var index = 0,\n      max = array.length,\n      ret = [];\n    if (!array || !max) {\n      return ret;\n    }\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n    return ret;\n  }\n\n  // pluck\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  }\n\n  // compact\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  }\n\n  // unique\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  }\n\n  // intersection\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  }\n\n  // rest\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  }\n\n  // initial\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  }\n\n  // extend\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n    return a;\n  }\n\n  // keys\n  function keys(a) {\n    var ret = [];\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        ret.push(key);\n      }\n    }\n    return ret;\n  }\n\n  // any\n  function any(array, callback) {\n    var index = 0,\n      max = array.length;\n    if (!array || !max) {\n      return false;\n    }\n    while (index < max) {\n      if (callback(array[index], index) === true) {\n        return true;\n      }\n      index += 1;\n    }\n    return false;\n  }\n\n  // flatten\n  function flatten(array) {\n    var ret = [];\n    each(array, function (child) {\n      ret = ret.concat(child);\n    });\n    return ret;\n  }\n  function toLocaleStringSupportsLocales() {\n    var number = 0;\n    try {\n      number.toLocaleString('i');\n    } catch (e) {\n      return e.name === 'RangeError';\n    }\n    return false;\n  }\n  function featureTestFormatterRounding(formatter) {\n    return formatter(3.55, \"en\", {\n      useGrouping: false,\n      minimumIntegerDigits: 1,\n      minimumFractionDigits: 1,\n      maximumFractionDigits: 1\n    }) === \"3.6\";\n  }\n  function featureTestFormatter(formatter) {\n    var passed = true;\n\n    // Test minimumIntegerDigits.\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 1\n    }) === \"1\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 2\n    }) === \"01\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 3\n    }) === \"001\";\n    if (!passed) {\n      return false;\n    }\n\n    // Test maximumFractionDigits and minimumFractionDigits.\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 0,\n      minimumFractionDigits: 0\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 1,\n      minimumFractionDigits: 1\n    }) === \"100.0\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 2,\n      minimumFractionDigits: 2\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 3,\n      minimumFractionDigits: 3\n    }) === \"99.990\";\n    if (!passed) {\n      return false;\n    }\n\n    // Test maximumSignificantDigits.\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 1\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 2\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 3\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 4\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 5\n    }) === \"99.99\";\n    if (!passed) {\n      return false;\n    }\n\n    // Test grouping.\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: true\n    }) === \"1,000\";\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: false\n    }) === \"1000\";\n    if (!passed) {\n      return false;\n    }\n    return true;\n  }\n\n  // durationsFormat(durations [, template] [, precision] [, settings])\n  function durationsFormat() {\n    var args = [].slice.call(arguments);\n    var settings = {};\n    var durations;\n\n    // Parse arguments.\n    each(args, function (arg, index) {\n      if (!index) {\n        if (!isArray(arg)) {\n          throw \"Expected array as the first argument to durationsFormat.\";\n        }\n        durations = arg;\n      }\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    if (!durations || !durations.length) {\n      return [];\n    }\n    settings.returnMomentTypes = true;\n    var formattedDurations = map(durations, function (dur) {\n      return dur.format(settings);\n    });\n\n    // Merge token types from all durations.\n    var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n    var largest = settings.largest;\n    if (largest) {\n      outputTypes = outputTypes.slice(0, largest);\n    }\n    settings.returnMomentTypes = false;\n    settings.outputTypes = outputTypes;\n    return map(durations, function (dur) {\n      return dur.format(settings);\n    });\n  }\n\n  // durationFormat([template] [, precision] [, settings])\n  function durationFormat() {\n    var args = [].slice.call(arguments);\n    var settings = extend({}, this.format.defaults);\n\n    // Keep a shadow copy of this moment for calculating remainders.\n    // Perform all calculations on positive duration value, handle negative\n    // sign at the very end.\n    var asMilliseconds = this.asMilliseconds();\n    var asMonths = this.asMonths();\n\n    // Treat invalid durations as having a value of 0 milliseconds.\n    if (typeof this.isValid === \"function\" && this.isValid() === false) {\n      asMilliseconds = 0;\n      asMonths = 0;\n    }\n    var isNegative = asMilliseconds < 0;\n\n    // Two shadow copies are needed because of the way moment.js handles\n    // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n    var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n    var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n    // Parse arguments.\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    var momentTokens = {\n      years: \"y\",\n      months: \"M\",\n      weeks: \"w\",\n      days: \"d\",\n      hours: \"h\",\n      minutes: \"m\",\n      seconds: \"s\",\n      milliseconds: \"S\"\n    };\n    var tokenDefs = {\n      escape: /\\[(.+?)\\]/,\n      years: /\\*?[Yy]+/,\n      months: /\\*?M+/,\n      weeks: /\\*?[Ww]+/,\n      days: /\\*?[Dd]+/,\n      hours: /\\*?[Hh]+/,\n      minutes: /\\*?m+/,\n      seconds: /\\*?s+/,\n      milliseconds: /\\*?S+/,\n      general: /.+?/\n    };\n\n    // Types array is available in the template function.\n    settings.types = types;\n    var typeMap = function (token) {\n      return find(types, function (type) {\n        return tokenDefs[type].test(token);\n      });\n    };\n    var tokenizer = new RegExp(map(types, function (type) {\n      return tokenDefs[type].source;\n    }).join(\"|\"), \"g\");\n\n    // Current duration object is available in the template function.\n    settings.duration = this;\n\n    // Eval template function and cache template string.\n    var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n    // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n    // outputTypes is an array of moment token types that determines\n    // the tokens returned in formatted output. This option overrides\n    // trim, largest, stopTrim, etc.\n    var outputTypes = settings.outputTypes;\n\n    // returnMomentTypes is a boolean that sets durationFormat to return\n    // the processed momentTypes instead of formatted output.\n    var returnMomentTypes = settings.returnMomentTypes;\n    var largest = settings.largest;\n\n    // Setup stopTrim array of token types.\n    var stopTrim = [];\n    if (!outputTypes) {\n      if (isArray(settings.stopTrim)) {\n        settings.stopTrim = settings.stopTrim.join(\"\");\n      }\n\n      // Parse stopTrim string to create token types array.\n      if (settings.stopTrim) {\n        each(settings.stopTrim.match(tokenizer), function (token) {\n          var type = typeMap(token);\n          if (type === \"escape\" || type === \"general\") {\n            return;\n          }\n          stopTrim.push(type);\n        });\n      }\n    }\n\n    // Cache moment's locale data.\n    var localeData = moment.localeData();\n    if (!localeData) {\n      localeData = {};\n    }\n\n    // Fall back to this plugin's `eng` extension.\n    each(keys(engLocale), function (key) {\n      if (typeof engLocale[key] === \"function\") {\n        if (!localeData[key]) {\n          localeData[key] = engLocale[key];\n        }\n        return;\n      }\n      if (!localeData[\"_\" + key]) {\n        localeData[\"_\" + key] = engLocale[key];\n      }\n    });\n\n    // Replace Duration Time Template strings.\n    // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n    each(keys(localeData._durationTimeTemplates), function (item) {\n      template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n    });\n\n    // Determine user's locale.\n    var userLocale = settings.userLocale || moment.locale();\n    var useLeftUnits = settings.useLeftUnits;\n    var usePlural = settings.usePlural;\n    var precision = settings.precision;\n    var forceLength = settings.forceLength;\n    var useGrouping = settings.useGrouping;\n    var trunc = settings.trunc;\n\n    // Use significant digits only when precision is greater than 0.\n    var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n    var significantDigits = useSignificantDigits ? settings.precision : 0;\n    var significantDigitsCache = significantDigits;\n    var minValue = settings.minValue;\n    var isMinValue = false;\n    var maxValue = settings.maxValue;\n    var isMaxValue = false;\n\n    // formatNumber fallback options.\n    var useToLocaleString = settings.useToLocaleString;\n    var groupingSeparator = settings.groupingSeparator;\n    var decimalSeparator = settings.decimalSeparator;\n    var grouping = settings.grouping;\n    useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks);\n\n    // Trim options.\n    var trim = settings.trim;\n    if (isArray(trim)) {\n      trim = trim.join(\" \");\n    }\n    if (trim === null && (largest || maxValue || useSignificantDigits)) {\n      trim = \"all\";\n    }\n    if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n      trim = \"large\";\n    }\n    if (trim === false) {\n      trim = \"\";\n    }\n    var trimIncludes = function (item) {\n      return item.test(trim);\n    };\n    var rLarge = /large/;\n    var rSmall = /small/;\n    var rBoth = /both/;\n    var rMid = /mid/;\n    var rAll = /^all|[^sm]all/;\n    var rFinal = /final/;\n    var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n    var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n    var trimMid = any([rMid, rAll], trimIncludes);\n    var trimFinal = any([rFinal, rAll], trimIncludes);\n\n    // Parse format string to create raw tokens array.\n    var rawTokens = map(template.match(tokenizer), function (token, index) {\n      var type = typeMap(token);\n      if (token.slice(0, 1) === \"*\") {\n        token = token.slice(1);\n        if (type !== \"escape\" && type !== \"general\") {\n          stopTrim.push(type);\n        }\n      }\n      return {\n        index: index,\n        length: token.length,\n        text: \"\",\n        // Replace escaped tokens with the non-escaped token text.\n        token: type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token,\n        // Ignore type on non-moment tokens.\n        type: type === \"escape\" || type === \"general\" ? null : type\n      };\n    });\n\n    // Associate text tokens with moment tokens.\n    var currentToken = {\n      index: 0,\n      length: 0,\n      token: \"\",\n      text: \"\",\n      type: null\n    };\n    var tokens = [];\n    if (useLeftUnits) {\n      rawTokens.reverse();\n    }\n    each(rawTokens, function (token) {\n      if (token.type) {\n        if (currentToken.type || currentToken.text) {\n          tokens.push(currentToken);\n        }\n        currentToken = token;\n        return;\n      }\n      if (useLeftUnits) {\n        currentToken.text = token.token + currentToken.text;\n      } else {\n        currentToken.text += token.token;\n      }\n    });\n    if (currentToken.type || currentToken.text) {\n      tokens.push(currentToken);\n    }\n    if (useLeftUnits) {\n      tokens.reverse();\n    }\n\n    // Find unique moment token types in the template in order of\n    // descending magnitude.\n    var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n    // Exit early if there are no moment token types.\n    if (!momentTypes.length) {\n      return pluck(tokens, \"text\").join(\"\");\n    }\n\n    // Calculate values for each moment type in the template.\n    // For processing the settings, values are associated with moment types.\n    // Values will be assigned to tokens at the last step in order to\n    // assume nothing about frequency or order of tokens in the template.\n    momentTypes = map(momentTypes, function (momentType, index) {\n      // Is this the least-magnitude moment token found?\n      var isSmallest = index + 1 === momentTypes.length;\n\n      // Is this the greatest-magnitude moment token found?\n      var isLargest = !index;\n\n      // Get the raw value in the current units.\n      var rawValue;\n      if (momentType === \"years\" || momentType === \"months\") {\n        rawValue = remainderMonths.as(momentType);\n      } else {\n        rawValue = remainder.as(momentType);\n      }\n      var wholeValue = Math.floor(rawValue);\n      var decimalValue = rawValue - wholeValue;\n      var token = find(tokens, function (token) {\n        return momentType === token.type;\n      });\n      if (isLargest && maxValue && rawValue > maxValue) {\n        isMaxValue = true;\n      }\n      if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n        isMinValue = true;\n      }\n\n      // Note the length of the largest-magnitude moment token:\n      // if it is greater than one and forceLength is not set,\n      // then default forceLength to `true`.\n      //\n      // Rationale is this: If the template is \"h:mm:ss\" and the\n      // moment value is 5 minutes, the user-friendly output is\n      // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n      // even though it has length of two if the template is \"h:mm:ss\";\n      //\n      // If the minutes output should always include the leading zero\n      // even when the hour is trimmed then set `{ forceLength: true }`\n      // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n      // clearly wanted everything padded so we should output \"05:00\";\n      //\n      // If the user wants the full padded output, they can use\n      // template \"hh:mm:ss\" and set `{ trim: false }` to output\n      // \"00:05:00\".\n      if (isLargest && forceLength === null && token.length > 1) {\n        forceLength = true;\n      }\n\n      // Update remainder.\n      remainder.subtract(wholeValue, momentType);\n      remainderMonths.subtract(wholeValue, momentType);\n      return {\n        rawValue: rawValue,\n        wholeValue: wholeValue,\n        // Decimal value is only retained for the least-magnitude\n        // moment type in the format template.\n        decimalValue: isSmallest ? decimalValue : 0,\n        isSmallest: isSmallest,\n        isLargest: isLargest,\n        type: momentType,\n        // Tokens can appear multiple times in a template string,\n        // but all instances must share the same length.\n        tokenLength: token.length\n      };\n    });\n    var truncMethod = trunc ? Math.floor : Math.round;\n    var truncate = function (value, places) {\n      var factor = Math.pow(10, places);\n      return truncMethod(value * factor) / factor;\n    };\n    var foundFirst = false;\n    var bubbled = false;\n    var formatValue = function (momentType, index) {\n      var formatOptions = {\n        useGrouping: useGrouping,\n        groupingSeparator: groupingSeparator,\n        decimalSeparator: decimalSeparator,\n        grouping: grouping,\n        useToLocaleString: useToLocaleString\n      };\n      if (useSignificantDigits) {\n        if (significantDigits <= 0) {\n          momentType.rawValue = 0;\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        } else {\n          formatOptions.maximumSignificantDigits = significantDigits;\n          momentType.significantDigits = significantDigits;\n        }\n      }\n      if (isMaxValue && !bubbled) {\n        if (momentType.isLargest) {\n          momentType.wholeValue = maxValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n      if (isMinValue && !bubbled) {\n        if (momentType.isSmallest) {\n          momentType.wholeValue = minValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n      if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n        // Apply precision to least significant token value.\n        if (precision < 0) {\n          momentType.value = truncate(momentType.wholeValue, precision);\n        } else if (precision === 0) {\n          momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n        } else {\n          // precision > 0\n          if (useSignificantDigits) {\n            if (trunc) {\n              momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n            } else {\n              momentType.value = momentType.rawValue;\n            }\n            if (momentType.wholeValue) {\n              significantDigits -= momentType.wholeValue.toString().length;\n            }\n          } else {\n            formatOptions.fractionDigits = precision;\n            if (trunc) {\n              momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n            } else {\n              momentType.value = momentType.wholeValue + momentType.decimalValue;\n            }\n          }\n        }\n      } else {\n        if (useSignificantDigits && momentType.wholeValue) {\n          // Outer Math.round required here to handle floating point errors.\n          momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n          significantDigits -= momentType.wholeValue.toString().length;\n        } else {\n          momentType.value = momentType.wholeValue;\n        }\n      }\n      if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n        formatOptions.minimumIntegerDigits = momentType.tokenLength;\n        if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n          delete formatOptions.maximumSignificantDigits;\n        }\n      }\n      if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        foundFirst = true;\n      }\n      momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n      formatOptions.useGrouping = false;\n      formatOptions.decimalSeparator = \".\";\n      momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n      if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n        momentType.formattedValueMS = formatNumber(momentType.value, {\n          minimumIntegerDigits: 3,\n          useGrouping: false\n        }, \"en\").slice(0, 2);\n      }\n      return momentType;\n    };\n\n    // Calculate formatted values.\n    momentTypes = map(momentTypes, formatValue);\n    momentTypes = compact(momentTypes);\n\n    // Bubble rounded values.\n    if (momentTypes.length > 1) {\n      var findType = function (type) {\n        return find(momentTypes, function (momentType) {\n          return momentType.type === type;\n        });\n      };\n      var bubbleTypes = function (bubble) {\n        var bubbleMomentType = findType(bubble.type);\n        if (!bubbleMomentType) {\n          return;\n        }\n        each(bubble.targets, function (target) {\n          var targetMomentType = findType(target.type);\n          if (!targetMomentType) {\n            return;\n          }\n          if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n            bubbleMomentType.rawValue = 0;\n            bubbleMomentType.wholeValue = 0;\n            bubbleMomentType.decimalValue = 0;\n            targetMomentType.rawValue += 1;\n            targetMomentType.wholeValue += 1;\n            targetMomentType.decimalValue = 0;\n            targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n            bubbled = true;\n          }\n        });\n      };\n      each(bubbles, bubbleTypes);\n    }\n\n    // Recalculate formatted values.\n    if (bubbled) {\n      foundFirst = false;\n      significantDigits = significantDigitsCache;\n      momentTypes = map(momentTypes, formatValue);\n      momentTypes = compact(momentTypes);\n    }\n    if (outputTypes && !(isMaxValue && !settings.trim)) {\n      momentTypes = map(momentTypes, function (momentType) {\n        if (find(outputTypes, function (outputType) {\n          return momentType.type === outputType;\n        })) {\n          return momentType;\n        }\n        return null;\n      });\n      momentTypes = compact(momentTypes);\n    } else {\n      // Trim Large.\n      if (trimLarge) {\n        momentTypes = rest(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - the smallest moment type\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n        });\n      }\n\n      // Largest.\n      if (largest && momentTypes.length) {\n        momentTypes = momentTypes.slice(0, largest);\n      }\n\n      // Trim Small.\n      if (trimSmall && momentTypes.length > 1) {\n        momentTypes = initial(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          // - the largest momentType\n          return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n        });\n      }\n\n      // Trim Mid.\n      if (trimMid) {\n        momentTypes = map(momentTypes, function (momentType, index) {\n          if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n            return null;\n          }\n          return momentType;\n        });\n        momentTypes = compact(momentTypes);\n      }\n\n      // Trim Final.\n      if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n        momentTypes = [];\n      }\n    }\n    if (returnMomentTypes) {\n      return momentTypes;\n    }\n\n    // Localize and pluralize unit labels.\n    each(tokens, function (token) {\n      var key = momentTokens[token.type];\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n      if (!key || !momentType) {\n        return;\n      }\n      var values = momentType.formattedValueEn.split(\".\");\n      values[0] = parseInt(values[0], 10);\n      if (values[1]) {\n        values[1] = parseFloat(\"0.\" + values[1], 10);\n      } else {\n        values[1] = null;\n      }\n      var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n      var labels = durationGetLabels(key, localeData);\n      var autoLocalized = false;\n      var pluralizedLabels = {};\n\n      // Auto-Localized unit labels.\n      each(localeData._durationLabelTypes, function (labelType) {\n        var label = find(labels, function (label) {\n          return label.type === labelType.type && label.key === pluralKey;\n        });\n        if (label) {\n          pluralizedLabels[label.type] = label.label;\n          if (stringIncludes(token.text, labelType.string)) {\n            token.text = token.text.replace(labelType.string, label.label);\n            autoLocalized = true;\n          }\n        }\n      });\n\n      // Auto-pluralized unit labels.\n      if (usePlural && !autoLocalized) {\n        labels.sort(durationLabelCompare);\n        each(labels, function (label) {\n          if (pluralizedLabels[label.type] === label.label) {\n            if (stringIncludes(token.text, label.label)) {\n              // Stop checking this token if its label is already\n              // correctly pluralized.\n              return false;\n            }\n\n            // Skip this label if it is correct, but not present in\n            // the token's text.\n            return;\n          }\n          if (stringIncludes(token.text, label.label)) {\n            // Replece this token's label and stop checking.\n            token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n            return false;\n          }\n        });\n      }\n    });\n\n    // Build ouptut.\n    tokens = map(tokens, function (token) {\n      if (!token.type) {\n        return token.text;\n      }\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n      if (!momentType) {\n        return \"\";\n      }\n      var out = \"\";\n      if (useLeftUnits) {\n        out += token.text;\n      }\n      if (isNegative && isMaxValue || !isNegative && isMinValue) {\n        out += \"< \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n      if (isNegative && isMinValue || !isNegative && isMaxValue) {\n        out += \"> \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n      if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        out += \"-\";\n        isNegative = false;\n      }\n      if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n        out += momentType.formattedValueMS;\n      } else {\n        out += momentType.formattedValue;\n      }\n      if (!useLeftUnits) {\n        out += token.text;\n      }\n      return out;\n    });\n\n    // Trim leading and trailing comma, space, colon, and dot.\n    return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n  }\n\n  // defaultFormatTemplate\n  function defaultFormatTemplate() {\n    var dur = this.duration;\n    var findType = function findType(type) {\n      return dur._data[type];\n    };\n    var firstType = find(this.types, findType);\n    var lastType = findLast(this.types, findType);\n\n    // Default template strings for each duration dimension type.\n    switch (firstType) {\n      case \"milliseconds\":\n        return \"S __\";\n      case \"seconds\": // Fallthrough.\n      case \"minutes\":\n        return \"*_MS_\";\n      case \"hours\":\n        return \"_HMS_\";\n      case \"days\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"d __\";\n        }\n      case \"weeks\":\n        if (firstType === lastType) {\n          return \"w __\";\n        }\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n        return \"w __, d __, h __\";\n      case \"months\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"M __\";\n        }\n      case \"years\":\n        if (firstType === lastType) {\n          return \"y __\";\n        }\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n        return \"y __, M __, d __\";\n      default:\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n        return \"y __, d __, h __, m __, s __\";\n    }\n  }\n\n  // init\n  function init(context) {\n    if (!context) {\n      throw \"Moment Duration Format init cannot find moment instance.\";\n    }\n    context.duration.format = durationsFormat;\n    context.duration.fn.format = durationFormat;\n    context.duration.fn.format.defaults = {\n      // Many options are defaulted to `null` to distinguish between\n      // 'not set' and 'set to `false`'\n\n      // trim\n      // Can be a string, a delimited list of strings, an array of strings,\n      // or a boolean.\n      // \"large\" - will trim largest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"small\" - will trim smallest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"both\" - will execute \"large\" trim then \"small\" trim.\n      // \"mid\" - will trim any zero-value tokens that are not the first or\n      // last tokens. Usually used in conjunction with \"large\" or \"both\".\n      // e.g. \"large mid\" or \"both mid\".\n      // \"final\" - will trim the final token if it is zero-value. Use this\n      // option with \"large\" or \"both\" to output an empty string when\n      // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n      // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n      // \"left\" - maps to \"large\" to support plugin's version 1 API.\n      // \"right\" - maps to \"large\" to support plugin's version 1 API.\n      // `false` - template tokens are not trimmed.\n      // `true` - treated as \"large\".\n      // `null` - treated as \"large\".\n      trim: null,\n      // stopTrim\n      // A moment token string, a delimited set of moment token strings,\n      // or an array of moment token strings. Trimming will stop when a token\n      // listed in this option is reached. A \"*\" character in the format\n      // template string will also mark a moment token as stopTrim.\n      // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n      stopTrim: null,\n      // largest\n      // Set to a positive integer to output only the \"n\" largest-magnitude\n      // moment tokens that have a value. All lesser-magnitude moment tokens\n      // will be ignored. This option takes effect even if `trim` is set\n      // to `false`.\n      largest: null,\n      // maxValue\n      // Use `maxValue` to render generalized output for large duration values,\n      // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n      /// applied to the greatest-magnitude moment token in the format template.\n      maxValue: null,\n      // minValue\n      // Use `minValue` to render generalized output for small duration values,\n      // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n      // applied to the least-magnitude moment token in the format template.\n      minValue: null,\n      // precision\n      // If a positive integer, number of decimal fraction digits to render.\n      // If a negative integer, number of integer place digits to truncate to 0.\n      // If `useSignificantDigits` is set to `true` and `precision` is a positive\n      // integer, sets the maximum number of significant digits used in the\n      // formatted output.\n      precision: 0,\n      // trunc\n      // Default behavior rounds final token value. Set to `true` to\n      // truncate final token value, which was the default behavior in\n      // version 1 of this plugin.\n      trunc: false,\n      // forceLength\n      // Force first moment token with a value to render at full length\n      // even when template is trimmed and first moment token has length of 1.\n      forceLength: null,\n      // userLocale\n      // Formatted numerical output is rendered using `toLocaleString`\n      // and the locale of the user's environment. Set this option to render\n      // numerical output using a different locale. Unit names are rendered\n      // and detected using the locale set in moment.js, which can be different\n      // from the locale of user's environment.\n      userLocale: null,\n      // usePlural\n      // Will automatically singularize or pluralize unit names when they\n      // appear in the text associated with each moment token. Standard and\n      // short unit labels are singularized and pluralized, based on locale.\n      // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n      // of \"1 seconds\" or \"1 secs\". The default pluralization function\n      // renders a plural label for a value with decimal precision.\n      // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n      // Label types and pluralization function are configurable in the\n      // localeData extensions.\n      usePlural: true,\n      // useLeftUnits\n      // The text to the right of each moment token in a format string\n      // is treated as that token's units for the purposes of trimming,\n      // singularizing, and auto-localizing.\n      // e.g. \"h [hours], m [minutes], s [seconds]\".\n      // To properly singularize or localize a format string such as\n      // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n      // to the left of each moment token, set useLeftUnits to `true`.\n      // This plugin is not tested in the context of rtl text.\n      useLeftUnits: false,\n      // useGrouping\n      // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useGrouping: true,\n      // useSignificantDigits\n      // Treat the `precision` option as the maximum significant digits\n      // to be rendered. Precision must be a positive integer. Significant\n      // digits extend across unit types,\n      // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n      // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useSignificantDigits: false,\n      // template\n      // The template string used to format the duration. May be a function\n      // or a string. Template functions are executed with the `this` binding\n      // of the settings object so that template strings may be dynamically\n      // generated based on the duration object (accessible via `this.duration`)\n      // or any of the other settings. Leading and trailing space, comma,\n      // period, and colon characters are trimmed from the resulting string.\n      template: defaultFormatTemplate,\n      // useToLocaleString\n      // Set this option to `false` to ignore the `toLocaleString` feature\n      // test and force the use of the `formatNumber` fallback function\n      // included in this plugin.\n      useToLocaleString: true,\n      // formatNumber fallback options.\n      // When `toLocaleString` is detected and passes the feature test, the\n      // following options will have no effect: `toLocaleString` will be used\n      // for formatting and the grouping separator, decimal separator, and\n      // integer digit grouping will be determined by the user locale.\n\n      // groupingSeparator\n      // The integer digit grouping separator used when using the fallback\n      // formatNumber function.\n      groupingSeparator: \",\",\n      // decimalSeparator\n      // The decimal separator used when using the fallback formatNumber\n      // function.\n      decimalSeparator: \".\",\n      // grouping\n      // The integer digit grouping used when using the fallback formatNumber\n      // function. Must be an array. The default value of `[3]` gives the\n      // standard 3-digit thousand/million/billion digit groupings for the\n      // \"en\" locale. Setting this option to `[3, 2]` would generate the\n      // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n      grouping: [3]\n    };\n    context.updateLocale('en', engLocale);\n  }\n\n  // Run feature tests for `Number#toLocaleString`.\n  var toLocaleStringFormatter = function (number, locale, options) {\n    return number.toLocaleString(locale, options);\n  };\n  toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n  toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter);\n\n  // Run feature tests for `Intl.NumberFormat#format`.\n  var intlNumberFormatFormatter = function (number, locale, options) {\n    if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n      return window.Intl.NumberFormat(locale, options).format(number);\n    }\n  };\n  intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n  intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter);\n\n  // Initialize duration format on the global moment instance.\n  init(moment);\n\n  // Return the init function so that duration format can be\n  // initialized on other moment instances.\n  return init;\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","require","e","momentDurationFormatSetup","moment","toLocaleStringWorks","toLocaleStringRoundingWorks","intlNumberFormatWorks","intlNumberFormatRoundingWorks","types","split","bubbles","type","targets","value","stringIncludes","str","search","length","indexOf","repeatZero","qty","result","stringRound","digits","digitsArray","reverse","i","carry","parseInt","toString","push","join","cachedNumberFormat","locale","options","optionsString","map","keys","sort","key","cacheKey","cache","Intl","NumberFormat","formatNumber","number","userLocale","useToLocaleString","useGrouping","grouping","slice","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","decimalSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","roundingOptions","extend","parseFloat","format","toLocaleString","numberString","toPrecision","toFixed","integerString","fractionString","exponentString","temp","integerLength","fractionLength","digitCount","replace","exponent","Math","abs","formattedString","group","shift","durationLabelCompare","a","b","label","durationGetLabels","token","localeData","labels","each","localeDataKey","labelType","toLowerCase","labelKey","durationPluralKey","integerValue","decimalValue","engLocale","durationLabelsStandard","S","SS","s","ss","m","mm","h","hh","d","dd","w","ww","M","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","string","isArray","array","Object","prototype","call","isObject","obj","findLast","callback","index","find","max","match","item","ret","pluck","prop","compact","unique","_a","intersection","_b","rest","initial","reversed","hasOwnProperty","any","flatten","child","concat","toLocaleStringSupportsLocales","name","featureTestFormatterRounding","formatter","featureTestFormatter","passed","durationsFormat","args","arguments","settings","durations","arg","template","precision","returnMomentTypes","formattedDurations","dur","outputTypes","largest","durationFormat","defaults","asMilliseconds","asMonths","isValid","isNegative","remainder","duration","remainderMonths","momentTokens","years","months","weeks","days","hours","minutes","seconds","milliseconds","tokenDefs","escape","general","typeMap","test","tokenizer","RegExp","source","apply","stopTrim","_durationTimeTemplates","useLeftUnits","usePlural","forceLength","trunc","useSignificantDigits","significantDigits","significantDigitsCache","minValue","isMinValue","maxValue","isMaxValue","trim","trimIncludes","rLarge","rSmall","rBoth","rMid","rAll","rFinal","trimLarge","trimSmall","trimMid","trimFinal","rawTokens","text","currentToken","tokens","momentTypes","momentType","isSmallest","isLargest","rawValue","as","wholeValue","floor","subtract","tokenLength","truncMethod","round","truncate","places","factor","pow","foundFirst","bubbled","formatValue","formatOptions","formattedValue","formattedValueEn","formattedValueMS","findType","bubbleTypes","bubble","bubbleMomentType","target","targetMomentType","outputType","values","pluralKey","autoLocalized","pluralizedLabels","_durationLabelTypes","out","defaultFormatTemplate","_data","firstType","lastType","init","context","fn","updateLocale","toLocaleStringFormatter","intlNumberFormatFormatter","window"],"sources":["C:/Users/ASUS/Desktop/VS code/yt/youtube-clone-frontend/node_modules/moment-duration-format/lib/moment-duration-format.js"],"sourcesContent":["/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // `Intl.NumberFormat#format` is tested on plugin initialization.\n    // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n    // `true` and the native function will be used to generate formatted output.\n    // If the feature test fails, either `Number#tolocaleString` (if\n    // `toLocaleStringWorks` is `true`), or the fallback format function internal\n    //  to this plugin will be used.\n    var intlNumberFormatWorks = false;\n\n    // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n    // formatting, the plugin will \"pre-round\" number values using the fallback number\n    // format function before passing them to `Intl.NumberFormat#format` for final\n    // formatting.\n    var intlNumberFormatRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // cachedNumberFormat\n    // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n    // On first use of a particular configuration, the instance is cached for fast\n    // repeat access.\n    function cachedNumberFormat(locale, options) {\n        // Create a sorted, stringified version of `options`\n        // for use as part of the cache key\n        var optionsString = map(\n            keys(options).sort(),\n            function(key) {\n                return key + ':' + options[key];\n            }\n        ).join(',');\n\n        // Set our cache key\n        var cacheKey = locale + '+' + optionsString;\n\n        // If we don't have this configuration cached, configure and cache it\n        if (!cachedNumberFormat.cache[cacheKey]) {\n            cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n        }\n\n        // Return the cached version of this configuration\n        return cachedNumberFormat.cache[cacheKey];\n    }\n    cachedNumberFormat.cache = {};\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n    // `userLocale` option is passed through to the formatting function.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (intlNumberFormatWorks) {\n                if (!intlNumberFormatRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n            } else {\n                if (!toLocaleStringRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return number.toLocaleString(userLocale, localeStringOptions);\n            }\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestFormatterRounding(formatter) {\n        return formatter(3.55, \"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestFormatter(formatter) {\n        var passed = true;\n\n        // Test minimumIntegerDigits.\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && formatter(1000, \"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && formatter(1000, \"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks);\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    var toLocaleStringFormatter = function(number, locale, options) {\n        return number.toLocaleString(locale, options);\n    };\n\n    toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter);\n\n    // Run feature tests for `Intl.NumberFormat#format`.\n    var intlNumberFormatFormatter = function(number, locale, options) {\n        if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n            return window.Intl.NumberFormat(locale, options).format(number);\n        }\n    };\n\n    intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n    intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter);\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}